File: ./tests/testing_helpers.go
package tests

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"testing"
	"time"

	"math/rand"

	"github.com/stretchr/testify/assert"
)

const (
	numUsers           = 100
	apiURL             = "http://localhost:8080/api"
	amountconst        = 1000
	numberofoperations = 10
)

var (
	items  = [10]string{"t-shirt", "cup", "book", "pen", "powerbank", "hoody", "umbrella", "socks", "wallet", "pink-hoody"}
	prices = [10]int{80, 20, 50, 10, 200, 300, 200, 10, 50, 500}
)

func authenticateUser(t *testing.T, username, password string) string {
	payload := fmt.Sprintf(`{"username": "%s", "password": "%s"}`, username, password)
	req, err := http.NewRequest("POST", apiURL+"/auth", bytes.NewBufferString(payload))
	assert.NoError(t, err, "Failed to create auth request")
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	assert.NoError(t, err, "Auth request failed")
	defer resp.Body.Close()

	assert.Equal(t, http.StatusOK, resp.StatusCode, "Auth should return 200 OK")

	var response map[string]interface{}
	err = json.NewDecoder(resp.Body).Decode(&response)
	assert.NoError(t, err, "Failed to decode auth response")

	jwtToken, ok := response["token"].(string)
	assert.True(t, ok, "JWT token not found in auth response")
	assert.NotEmpty(t, jwtToken, "JWT token should not be empty")

	return jwtToken
}

func makeRequest(t *testing.T, method, url, token string, body []byte) *http.Response {
	req, err := http.NewRequest(method, url, bytes.NewBuffer(body))
	assert.NoError(t, err, "Failed to create request")
	if token != "" {
		req.Header.Set("Authorization", "Bearer "+token)
	}
	if method == "POST" || method == "PUT" {
		req.Header.Set("Content-Type", "application/json")
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	assert.NoError(t, err, "Request failed")
	return resp
}

func GenerateRandomStringSample(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	if length <= 0 {
		return ""
	}

	var seededRand *rand.Rand = rand.New(rand.NewSource(time.Now().UnixNano()))
	var result strings.Builder

	for i := 0; i < length; i++ {
		randomIndex := seededRand.Intn(len(charset))
		result.WriteByte(charset[randomIndex])
	}

	return result.String()
}

func Generate_Username_Password(i int) (string, string) {
	prefix := GenerateRandomStringSample(6)
	username := prefix + "_" + strconv.Itoa(i)
	password := prefix
	return username, password
}
File: ./tests/2_test.go
package tests

import (
	"fmt"
	"net/http"
	"sync"
	"testing"
	"time"
)

func TestLoadCoinTransferBetweenOddAndEvenUsers(t *testing.T) {
	const (
		numUsers       = 1000 // Total number of users
		numIterations  = 10   // Number of transfers per user
		transferAmount = 1    // Amount to transfer each time
	)

	var wg sync.WaitGroup
	wg.Add(numUsers)

	startTime := time.Now()

	// Authenticate all users and store their tokens
	tokens := make([]string, numUsers)
	for i := 0; i < numUsers; i++ {
		temp := fmt.Sprintf("user_%d", i)
		username, password := temp, temp
		tokens[i] = authenticateUser(t, username, password)
	}

	// Simulate transfers between odd and even users
	for i := 0; i < numUsers; i++ {
		go func(userID int) {
			defer wg.Done()

			for j := 0; j < numIterations; j++ {
				// Determine the target user
				targetUserID := (userID + 1) % numUsers // Transfer to the next user
				if userID%2 == 0 {                      // Even users send to odd users
					targetUserID = (userID + 1) % numUsers
				} else { // Odd users send to even users
					targetUserID = (userID - 1 + numUsers) % numUsers
				}

				// Get the target user's username
				targetUsername := fmt.Sprintf("user_%d", targetUserID)

				// Prepare the request payload
				payload := fmt.Sprintf(`{"amount": %d, "toUser": "%s"}`, transferAmount, targetUsername)
				resp := makeRequest(t, "POST", apiURL+"/sendCoin", tokens[userID], []byte(payload))
				counter := 10
				for counter > 0 && (resp.StatusCode != http.StatusOK) {
					resp = makeRequest(t, "POST", apiURL+"/sendCoin", tokens[userID], []byte(payload))
					counter--
				}
				if resp.StatusCode != http.StatusOK {
					t.Errorf("User %d: Received non-200 status during transfer: %d\n", userID, resp.StatusCode)
				}
				t.Logf("User %d: Received Status Code %d", userID, resp.StatusCode)

			}
		}(i)
	}

	wg.Wait()

	// Log the total time taken
	t.Logf("Load test completed in %v", time.Since(startTime))
	t.Logf("Total transfers: %d", numUsers*numIterations)
	t.Logf("Average response time: %v", time.Since(startTime)/(numUsers*numIterations))
}
File: ./tests/1_test.go
package tests

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"sync"
	"testing"
	"time"

	"math/rand"
)

func TestAuthAndBuy(t *testing.T) {
	var wg sync.WaitGroup
	wg.Add(numUsers)
	rand.Seed(time.Now().UnixNano()) // Use current time as seed)

	startTime := time.Now()

	for i := 0; i < numUsers; i++ {
		go func(userID int) {
			defer wg.Done()
			username, password := Generate_Username_Password(userID)
			// Prepare the request payload
			payload := fmt.Sprintf(`{"username": "%s", "password": "%s"}`, username, password)
			req, err := http.NewRequest("POST", apiURL+"/auth", bytes.NewBufferString(payload))
			if err != nil {
				t.Errorf("User %d: Failed to create request: %v\n", userID, err)
				return
			}
			req.Header.Set("Content-Type", "application/json")
			client := &http.Client{}
			resp, err := client.Do(req)
			if err != nil {
				t.Errorf("User %d: Request failed: %v\n", userID, err)
				return
			}
			if resp.StatusCode != http.StatusOK {
				t.Errorf("User %d: Received non-200 status during auth: %d\n", userID, resp.StatusCode)
				return
			}
			var response map[string]interface{}
			if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
				t.Errorf("User %d: Failed to decode auth response: %v\n", userID, err)
				return
			}
			jwtToken := response["token"].(string)
			resp.Body.Close()
			if jwtToken == "" {
				t.Errorf("User %d: JWT token not found in auth response\n", userID)
			}
			var chosen_item int
			amount := amountconst
			for j := 0; j < numberofoperations; j++ {
				if j%5 != userID%5 {
					chosen_item = 9
				} else {
					chosen_item = rand.Intn(10)
				}
				req, err = http.NewRequest("GET", apiURL+"/buy/"+items[chosen_item], nil)
				req.Header.Set("Authorization", "Bearer "+jwtToken)
				if err != nil {
					t.Errorf("User %d: Failed to create request: %v\n", userID, err)
					return
				}
				resp, err = client.Do(req)
				if err != nil {
					t.Errorf("User %d: Request failed: %v\n", userID, err)
					return
				}
				if prices[chosen_item] > amount && resp.StatusCode != http.StatusBadRequest {
					t.Errorf("User %d: Didn't receive 400 status when he should've: %d\n", userID, resp.StatusCode)
					return
				} else if prices[chosen_item] <= amount && resp.StatusCode != http.StatusOK {
					t.Errorf("User %d: Received non-200 status: %d\n", userID, resp.StatusCode)
					return
				}
				resp.Body.Close()
				if prices[chosen_item] <= amount {
					amount -= prices[chosen_item]
				}
			}
			/*
				req.Header.Set("Authorization", "Bearer "+jwtToken)
				defer resp.Body.Close()

				// Check the response status
				if resp.StatusCode != http.StatusOK {
					fmt.Printf("User %d: Received non-200 status: %d\n", userID, resp.StatusCode)
					return
				}
			*/

			t.Logf("User %d: Request successful\n", userID)
		}(i)
	}

	wg.Wait()

	t.Logf("Load test completed in %v\n", time.Since(startTime))
	t.Logf("average response time: %v\n", time.Since(startTime)/(time.Duration(numUsers)*numberofoperations))
}
File: ./internal/data/shop.go
package data

import (
	"database/sql"
	"errors"
	"strings"
)

type User struct {
	ID       int64  `json:"id"`
	Balance  int    `json:"coins"`
	Username string `json:"username"`
	Password string `json:"-"`
}
type Item struct {
	ID       int64  `json:"-"`
	Name     string `json:"item"`
	Price    int    `json:"-"`
	Quantity int    `json:"quantity"`
}
type UserItem struct {
	User_id  int64
	Item_id  int64
	Quantity int
}
type Transcation struct {
	ID         int64
	FromUserID int
	ToUserID   int
	Amount     int
}

type ShopModel struct {
	DB *sql.DB
}

func (m *ShopModel) GetUserByUsername(username string) (*User, error) {
	stmt := `SELECT id, username, password, balance FROM users WHERE username = $1`

	row := m.DB.QueryRow(stmt, username)

	var user User
	err := row.Scan(&user.ID, &user.Username, &user.Password, &user.Balance)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	return &user, nil
}

func (m *ShopModel) InsertUser(username string, password string) (*User, error) {
	stmt := `INSERT INTO users (username, password) VALUES ($1, $2) RETURNING id, balance`

	var newUser User
	err := m.DB.QueryRow(stmt, username, password).Scan(&newUser.ID, &newUser.Balance)
	if err != nil {
		return nil, err
	}
	newUser.Username = username
	return &newUser, nil
}

func (m *ShopModel) GetUserBalanceAndInventory(userID int64) (int, []Item, error) {
	stmt := `
        SELECT u.balance, i.id, i.name, i.price, ui.quantity
        FROM users u
        LEFT JOIN user_items ui ON u.id = ui.user_id
        LEFT JOIN items i ON ui.item_id = i.id
        WHERE u.id = $1
    `

	rows, err := m.DB.Query(stmt, userID)
	if err != nil {
		return 0, nil, err
	}
	defer rows.Close()

	var balance int
	inventoryItems := []Item{}

	hasRows := false
	for rows.Next() {

		var currentBalance int
		var itemID sql.NullInt64
		var name sql.NullString
		var price sql.NullInt64
		var quantity sql.NullInt64

		if err := rows.Scan(&currentBalance, &itemID, &name, &price, &quantity); err != nil {
			return 0, nil, err
		}

		// Set balance from the first row
		if !hasRows {
			balance = currentBalance
		}

		hasRows = true

		// Handle NULL values for name, price, and quantity
		item := Item{
			ID:       itemID.Int64,        // If itemID is NULL, this will be 0
			Name:     name.String,         // If name is NULL, this will be an empty string
			Price:    int(price.Int64),    // If price is NULL, this will be 0
			Quantity: int(quantity.Int64), // If quantity is NULL, this will be 0
		}

		// Only append the item if it has a valid name (i.e., not NULL)
		if name.Valid {
			inventoryItems = append(inventoryItems, item)
		}
	}

	if err := rows.Err(); err != nil {
		return 0, nil, err
	}

	// If no rows were returned, fetch the user's balance separately
	if !hasRows {
		balance, err = m.GetUserBalance(userID)
		if err != nil {
			return 0, nil, err
		}
	}

	return balance, inventoryItems, nil
}

func (m *ShopModel) GetUserBalance(userID int64) (int, error) {
	stmt := `SELECT balance FROM users WHERE id = $1`
	var balance int
	err := m.DB.QueryRow(stmt, userID).Scan(&balance)
	if err != nil {
		return 0, err
	}
	return balance, nil
}

func (m *ShopModel) UpdateSenderBalance(tx *sql.Tx, userID int64, amount int) error {
	stmt := `UPDATE users SET balance = balance - $1 WHERE id = $2`
	_, err := tx.Exec(stmt, amount, userID)
	return err
}

func (m *ShopModel) UpdateReceiverBalance(tx *sql.Tx, userID int64, amount int) error {
	stmt := `UPDATE users SET balance = balance + $1 WHERE id = $2`
	_, err := tx.Exec(stmt, amount, userID)
	return err
}

func (m *ShopModel) InsertTransaction(tx *sql.Tx, fromUserID int64, toUserID int64, amount int) error {
	stmt := `
		INSERT INTO transactions (from_user_id, to_user_id, amount)
		VALUES ($1, $2, $3)
	`
	_, err := tx.Exec(stmt, fromUserID, toUserID, amount)
	return err
}

func (m *ShopModel) GetItemPrice(itemName string) (int, error) {
	stmt := `SELECT price FROM items WHERE name = $1`
	var price int
	err := m.DB.QueryRow(stmt, itemName).Scan(&price)
	if err != nil {
		return 0, err
	}
	return price, nil
}

func (m *ShopModel) UpdateUserBalanceAfterPurchase(tx *sql.Tx, userID int64, itemPrice int) error {
	stmt := `UPDATE users SET balance = balance - $1 WHERE id = $2`
	_, err := tx.Exec(stmt, itemPrice, userID)
	return err
}

func (m *ShopModel) InsertUserItem(tx *sql.Tx, userID int64, itemID int64) error {
	stmt := `INSERT INTO user_items (user_id, item_id) VALUES ($1, $2)
	ON CONFLICT (user_id, item_id)
	DO UPDATE SET quantity = user_items.quantity+1
	`
	_, err := tx.Exec(stmt, userID, itemID)
	return err
}

func (m *ShopModel) GetAllItems() ([]Item, error) {
	stmt := `SELECT id, name, price FROM items`

	rows, err := m.DB.Query(stmt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var items []Item

	for rows.Next() {
		var i Item
		err := rows.Scan(&i.ID, &i.Name, &i.Price)
		if err != nil {
			return nil, err
		}
		items = append(items, i)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return items, nil
}

func (m *ShopModel) CheckUserOwnItem(userID int64, itemID int64) (bool, error) {
	stmt := `SELECT EXISTS(SELECT 1 FROM user_items WHERE user_id = $1 AND item_id = $2)`
	var exists bool
	err := m.DB.QueryRow(stmt, userID, itemID).Scan(&exists)
	if err != nil {
		return false, err
	}
	return exists, nil
}

func (m *ShopModel) GetUserByID(userID int64) (*User, error) {
	stmt := `SELECT id, username, balance FROM users WHERE id = $1`

	row := m.DB.QueryRow(stmt, userID)

	var user User
	err := row.Scan(&user.ID, &user.Username, &user.Balance)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	return &user, nil
}

func (m *ShopModel) GetItemByName(itemName string) (*Item, error) {
	stmt := `SELECT id, name, price FROM items WHERE name = $1`

	row := m.DB.QueryRow(stmt, itemName)

	var item Item
	err := row.Scan(&item.ID, &item.Name, &item.Price)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	return &item, nil
}

func (m *ShopModel) GetItemByID(itemID int64) (*Item, error) {
	stmt := `SELECT id, name, price FROM items WHERE id = $1`

	row := m.DB.QueryRow(stmt, itemID)

	var item Item
	err := row.Scan(&item.ID, &item.Name, &item.Price)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	return &item, nil
}

func (m *ShopModel) GetUsersByIDs(userIDs []int64) (map[int64]*User, error) {
	if len(userIDs) == 0 {
		return nil, nil
	}

	query := `SELECT id, username FROM users WHERE id IN (` + strings.Repeat("?,", len(userIDs)-1) + `?)`
	args := make([]interface{}, len(userIDs))
	for i, id := range userIDs {
		args[i] = id
	}

	rows, err := m.DB.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	users := make(map[int64]*User)
	for rows.Next() {
		var user User
		if err := rows.Scan(&user.ID, &user.Username); err != nil {
			return nil, err
		}
		users[user.ID] = &user
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return users, nil
}

func (m *ShopModel) GetTransactionHistoryWithUsernames(userID int64) ([]struct {
	FromUserID int64
	ToUserID   int64
	FromUser   string
	ToUser     string
	Amount     int
}, error) {
	stmt := `
		SELECT
			t.from_user_id, t.to_user_id,
			u1.username AS from_user,
			u2.username AS to_user,
			t.amount
		FROM transactions t
		LEFT JOIN users u1 ON t.from_user_id = u1.id
		LEFT JOIN users u2 ON t.to_user_id = u2.id
		WHERE t.from_user_id = $1 OR t.to_user_id = $1
		ORDER BY t.id DESC
	`

	rows, err := m.DB.Query(stmt, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var transactions []struct {
		FromUserID int64
		ToUserID   int64
		FromUser   string
		ToUser     string
		Amount     int
	}

	for rows.Next() {
		var t struct {
			FromUserID int64
			ToUserID   int64
			FromUser   sql.NullString
			ToUser     sql.NullString
			Amount     int
		}
		if err := rows.Scan(&t.FromUserID, &t.ToUserID, &t.FromUser, &t.ToUser, &t.Amount); err != nil {
			return nil, err
		}

		// Convert sql.NullString to string, handling NULL values
		fromUser := ""
		if t.FromUser.Valid {
			fromUser = t.FromUser.String
		}

		toUser := ""
		if t.ToUser.Valid {
			toUser = t.ToUser.String
		}

		transactions = append(transactions, struct {
			FromUserID int64
			ToUserID   int64
			FromUser   string
			ToUser     string
			Amount     int
		}{
			FromUserID: t.FromUserID,
			ToUserID:   t.ToUserID,
			FromUser:   fromUser,
			ToUser:     toUser,
			Amount:     t.Amount,
		})
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return transactions, nil
}

/*
func (m *ShopModel) GetTransactionHistoryWithUsernames(userID int64) ([]struct {
	FromUserID int64
	ToUserID   int64
	FromUser   string
	ToUser     string
	Amount     int
}, error) {
	stmt := `
		SELECT
			t.from_user_id, t.to_user_id,
			u1.username AS from_user,
			u2.username AS to_user,
			t.amount
		FROM transactions t
		LEFT JOIN users u1 ON t.from_user_id = u1.id
		LEFT JOIN users u2 ON t.to_user_id = u2.id
		WHERE t.from_user_id = $1 OR t.to_user_id = $1
		ORDER BY t.id DESC
	`

	rows, err := m.DB.Query(stmt, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var transactions []struct {
		FromUserID int64
		ToUserID   int64
		FromUser   string
		ToUser     string
		Amount     int
	}

	for rows.Next() {
		var t struct {
			FromUserID int64
			ToUserID   int64
			FromUser   string
			ToUser     string
			Amount     int
		}
		if err := rows.Scan(&t.FromUserID, &t.ToUserID, &t.FromUser, &t.ToUser, &t.Amount); err != nil {
			return nil, err
		}
		transactions = append(transactions, t)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	return transactions, nil
}
*/
File: ./internal/data/models.go
package data

import (
	"database/sql"
	"errors"
)

var (
	ErrRecordNotFound = errors.New("record not found")
)

type Models struct {
	Shop ShopModel
}

func NewModels(db *sql.DB) Models {
	return Models{
		Shop: ShopModel{DB: db},
	}
}
File: ./internal/validator/validator.go
package validator

import "regexp"

var (
	EmailRX = regexp.MustCompile("^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
)

type Validator struct {
	Errors map[string]string
}

func New() *Validator {
	return &Validator{Errors: make(map[string]string)}
}

func (v *Validator) Valid() bool {
	return len(v.Errors) == 0
}

func (v *Validator) AddError(key, message string) {
	if _, exists := v.Errors[key]; !exists {
		v.Errors[key] = message
	}
}

func (v *Validator) Check(ok bool, key, message string) {
	if !ok {
		v.AddError(key, message)
	}
}

func PermittedValue[T comparable](value T, permittedValues ...T) bool {
	for i := range permittedValues {
		if value == permittedValues[i] {
			return true
		}
	}
	return false
}

func Matches(value string, rx *regexp.Regexp) bool {
	return rx.MatchString(value)
}

func Unique[T comparable](values []T) bool {
	uniqueValues := make(map[T]bool)

	for _, value := range values {
		uniqueValues[value] = true
	}
	return len(values) == len(uniqueValues)
}
File: ./internal/cmd/shop.go
package main

import (
	"context"
	"errors"
	"net/http"

	"github.com/julienschmidt/httprouter"
	"github.com/wisp167/Shop/internal/data"
)

func (app *application) buyItemHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	app.queue <- struct{}{}
	defer func() {
		<-app.queue
	}()
	app.buyItemWorker(w, r, ps)
}

func (app *application) buyItemWorker(w http.ResponseWriter, r *http.Request, ps httprouter.Params) (err error) {
	itemName := ps.ByName("item")
	if itemName == "" {
		app.logger.Println("No item name provided")
		app.badRequestResponse(w, r)
		return nil
	}
	userID, ok := r.Context().Value("id").(int64)
	if !ok {
		app.serverErrorResponse(w, r, errors.New("cannot get user id"))
		return nil
	}
	tx, err := app.models.Shop.DB.BeginTx(context.Background(), nil)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}

	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	item, err := app.models.Shop.GetItemByName(itemName)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}
	if item == nil {
		app.badRequestResponse(w, r)
		err = errors.New("item not found")
		return err
	}
	user, err := app.models.Shop.GetUserByID(userID)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}
	if user.Balance < item.Price {
		app.badRequestResponse(w, r)
		err = errors.New("")
		return err
	}
	err = app.models.Shop.UpdateUserBalanceAfterPurchase(tx, userID, item.Price)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		err = errors.New("")
		return err
	}
	err = app.models.Shop.InsertUserItem(tx, userID, item.ID)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}
	err = tx.Commit()
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}
	app.writeJSON(w, http.StatusOK, envelope{}, nil)
	return nil
}

func (app *application) sendCoinHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	app.queue <- struct{}{}
	defer func() {
		<-app.queue
	}()
	app.sendCoinWorker(w, r, httprouter.Params{})
}
func (app *application) sendCoinWorker(w http.ResponseWriter, r *http.Request, ps httprouter.Params) (err error) {
	var request struct {
		Amount   int    `json:"amount"`
		Receiver string `json:"toUser"`
	}

	// Read and parse the JSON request body
	if err := app.readJSON(w, r, &request); err != nil {
		app.logger.Printf("Error reading JSON: %v", err)
		app.badRequestResponse(w, r)
		return err
	}

	// Validate the request
	if request.Amount <= 0 || request.Receiver == "" {
		app.logger.Println("Invalid request: amount or receiver is empty")
		app.badRequestResponse(w, r)
		return errors.New("invalid request")
	}

	// Get the user ID from the context
	userID, ok := r.Context().Value("id").(int64)
	if !ok {
		app.serverErrorResponse(w, r, errors.New("cannot get user id"))
		return errors.New("cannot get user id")
	}

	// Start a database transaction
	tx, err := app.models.Shop.DB.BeginTx(context.Background(), nil)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Get the sender's details
	sender, err := app.models.Shop.GetUserByID(userID)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}

	// Validate sender's balance and receiver
	if sender.Balance < request.Amount || sender.Username == request.Receiver {
		app.badRequestResponse(w, r)
		return errors.New("insufficient balance or invalid receiver")
	}

	// Update sender's balance
	if err := app.models.Shop.UpdateSenderBalance(tx, userID, request.Amount); err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}

	// Get the receiver's details
	receiver, err := app.models.Shop.GetUserByUsername(request.Receiver)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}
	if receiver == nil {
		app.badRequestResponse(w, r)
		return errors.New("receiver not found")
	}

	// Update receiver's balance
	if err := app.models.Shop.UpdateReceiverBalance(tx, receiver.ID, request.Amount); err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}

	// Record the transaction
	if err := app.models.Shop.InsertTransaction(tx, sender.ID, receiver.ID, request.Amount); err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}

	// Commit the transaction
	if err := tx.Commit(); err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}

	// Return a success response
	app.writeJSON(w, http.StatusOK, envelope{}, nil)
	return nil
}

func (app *application) getInfoHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	app.queue <- struct{}{}
	defer func() {
		<-app.queue
	}()
	app.getInfoWorker(w, r, ps)
}

func (app *application) getInfoWorker(w http.ResponseWriter, r *http.Request, ps httprouter.Params) (err error) {
	// Get the user ID from the context
	userID, ok := r.Context().Value("id").(int64)
	if !ok {
		app.serverErrorResponse(w, r, errors.New("cannot get user id"))
		return errors.New("cannot get user id")
	}

	// Fetch user balance and inventory
	balance, inventory, err := app.models.Shop.GetUserBalanceAndInventory(userID)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}

	// Fetch transaction history with usernames
	transactions, err := app.models.Shop.GetTransactionHistoryWithUsernames(userID)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}

	// Prepare the response
	response := struct {
		Coins       int         `json:"coins"`
		Inventory   []data.Item `json:"inventory"`
		CoinHistory struct {
			Received []struct {
				FromUser string `json:"fromUser"`
				Amount   int    `json:"amount"`
			} `json:"received"`
			Sent []struct {
				ToUser string `json:"toUser"`
				Amount int    `json:"amount"`
			} `json:"sent"`
		} `json:"coinHistory"`
	}{
		Coins:     balance,
		Inventory: inventory,
	}

	// Populate the coin history
	for _, t := range transactions {
		if t.ToUserID == userID {
			// Received transaction
			response.CoinHistory.Received = append(response.CoinHistory.Received, struct {
				FromUser string `json:"fromUser"`
				Amount   int    `json:"amount"`
			}{
				FromUser: t.FromUser,
				Amount:   t.Amount,
			})
		} else if t.FromUserID == userID {
			// Sent transaction
			response.CoinHistory.Sent = append(response.CoinHistory.Sent, struct {
				ToUser string `json:"toUser"`
				Amount int    `json:"amount"`
			}{
				ToUser: t.ToUser,
				Amount: t.Amount,
			})
		}
	}

	// Return the response
	app.writeJSON(w, http.StatusOK, response, nil)
	return nil
}

/*
func (app *application) getInfoWorker(w http.ResponseWriter, r *http.Request, ps httprouter.Params) (err error) {
	// Get the user ID from the context
	userID, ok := r.Context().Value("id").(int64)
	if !ok {
		app.serverErrorResponse(w, r, errors.New("cannot get user id"))
		return errors.New("cannot get user id")
	}

	// Fetch user balance and inventory
	balance, inventory, err := app.models.Shop.GetUserBalanceAndInventory(userID)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}

	// Fetch transaction history
	transactions, err := app.models.Shop.GetTransactionHistory(userID)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return err
	}

	// Prepare the response
	response := struct {
		Coins       int         `json:"coins"`
		Inventory   []data.Item `json:"inventory"`
		CoinHistory struct {
			Received []struct {
				FromUser string `json:"fromUser"`
				Amount   int    `json:"amount"`
			} `json:"received"`
			Sent []struct {
				ToUser string `json:"toUser"`
				Amount int    `json:"amount"`
			} `json:"sent"`
		} `json:"coinHistory"`
	}{
		Coins:     balance,
		Inventory: inventory,
	}

	// Populate the coin history
	for _, t := range transactions {
		if t.ToUserID == int(userID) {
			// Received transaction
			fromUser, err := app.models.Shop.GetUserByID(int64(t.FromUserID))
			if err != nil {
				app.serverErrorResponse(w, r, err)
				return err
			}
			response.CoinHistory.Received = append(response.CoinHistory.Received, struct {
				FromUser string `json:"fromUser"`
				Amount   int    `json:"amount"`
			}{
				FromUser: fromUser.Username,
				Amount:   t.Amount,
			})
		} else if t.FromUserID == int(userID) {
			// Sent transaction
			toUser, err := app.models.Shop.GetUserByID(int64(t.ToUserID))
			if err != nil {
				app.serverErrorResponse(w, r, err)
				return err
			}
			response.CoinHistory.Sent = append(response.CoinHistory.Sent, struct {
				ToUser string `json:"toUser"`
				Amount int    `json:"amount"`
			}{
				ToUser: toUser.Username,
				Amount: t.Amount,
			})
		}
	}

	app.writeJSON(w, http.StatusOK, response, nil)
	return nil
}
*/
File: ./internal/cmd/errors.go
package main

import (
	"fmt"
	"net/http"
	"runtime"
	"strings"
)

func (app *application) logError(r *http.Request, err error) {
	_, file, line, ok := runtime.Caller(2)
	if !ok {
		file = "unknown"
		line = 0
	}
	_, file1, line1, ok1 := runtime.Caller(3)
	if !ok1 {
		file1 = "unknown"
		line = 0
	}

	// Extract just the filename from the full path
	fileParts := strings.Split(file, "/")
	filename := fileParts[len(fileParts)-1]
	fileParts = strings.Split(file1, "/")
	filename1 := fileParts[len(fileParts)-1]
	// Log the error with the file and line number
	app.logger.Printf("[%s:%d]->[%s:%d] %v", filename, line, filename1, line1, err)
}

func (app *application) errorResponse(w http.ResponseWriter, r *http.Request, status int, message any) {
	env := envelope{"error": message}
	err := app.writeJSON(w, status, env, nil)
	if err != nil {
		app.logError(r, err)
	}
}

func (app *application) serverErrorResponse(w http.ResponseWriter, r *http.Request, err error) {
	app.logError(r, err)

	message := "Внутренняя ошибка сервера."
	app.errorResponse(w, r, http.StatusInternalServerError, message)
}

func (app *application) notFoundResponse(w http.ResponseWriter, r *http.Request) {
	message := "the requested resource could not be found"
	app.errorResponse(w, r, http.StatusMethodNotAllowed, message)
}

func (app *application) methodNotAllowedResponse(w http.ResponseWriter, r *http.Request) {
	message := fmt.Sprintf("the %s method is not supported for this resource", r.Method)
	app.errorResponse(w, r, http.StatusMethodNotAllowed, message)
}

func (app *application) badRequestResponse(w http.ResponseWriter, r *http.Request) {
	message := fmt.Sprintf("Неверный запрос.")
	app.errorResponse(w, r, http.StatusBadRequest, message)
}

func (app *application) failedValidationResponse(w http.ResponseWriter, r *http.Request, errors map[string]string) {
	app.errorResponse(w, r, http.StatusUnprocessableEntity, errors)
}

func (app *application) authorizationErrorResponse(w http.ResponseWriter, r *http.Request) {
	message := fmt.Sprintf("Неавторизован.")
	app.errorResponse(w, r, http.StatusUnauthorized, message)
}
File: ./internal/cmd/helpers.go
package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"

	"github.com/julienschmidt/httprouter"
)

type envelope map[string]any

func (app *application) readJSON(w http.ResponseWriter, r *http.Request, dst any) error {
	// Decode the request bodt into the target destination
	maxBytes := 1_048_576
	r.Body = http.MaxBytesReader(w, r.Body, int64(maxBytes))

	dec := json.NewDecoder(r.Body)
	dec.DisallowUnknownFields()

	err := dec.Decode(dst)
	if err != nil {
		var syntaxError *json.SyntaxError
		var unmarshalTypeError *json.UnmarshalTypeError
		var invalidUnmarshalError *json.InvalidUnmarshalError
		var maxBytesError *http.MaxBytesError

		switch {
		case errors.As(err, &syntaxError):
			return fmt.Errorf("body contains badly formed JSON (at character %d)", syntaxError.Offset)
		case errors.Is(err, io.ErrUnexpectedEOF):
			return errors.New("body contains badly formed JSON")
		case errors.As(err, &unmarshalTypeError):
			if unmarshalTypeError.Field != "" {
				return fmt.Errorf("body contains incorrect JSON type for field %q", unmarshalTypeError.Field)
			}
			return fmt.Errorf("body contains incorrect JSON type (at character %d)", unmarshalTypeError.Offset)
		case strings.HasPrefix(err.Error(), "json: unknown field"):
			fieldName := strings.TrimPrefix(err.Error(), "json: unknown field")
			return fmt.Errorf("body contains unknown key %s", fieldName)
		case errors.Is(err, io.EOF):
			return errors.New("body must not be empty")
		case errors.As(err, &maxBytesError):
			return fmt.Errorf("body must not be larger than %d bytes", maxBytes)
		case errors.As(err, &invalidUnmarshalError):
			panic(err)
		default:
			return err
		}
	}
	err = dec.Decode(&struct{}{})
	if err != io.EOF {
		return errors.New("body must only contain a single JSON value")
	}
	return nil
}

func (app *application) writeJSON(w http.ResponseWriter, status int, data any, headers http.Header) error {

	js, err := json.MarshalIndent(data, "", "\t")
	if err != nil {
		return err
	}
	js = append(js, '\n')

	for key, value := range headers {
		w.Header()[key] = value
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	w.Write(js)
	return nil
}

func (app *application) readIDParam(r *http.Request) (int64, error) {
	params := httprouter.ParamsFromContext(r.Context())
	id, err := strconv.ParseInt(params.ByName("id"), 10, 64)
	if err != nil || id < 1 {
		return 0, errors.New("invalid id parameter")
	}

	return id, nil
}

func wrapHandle(h httprouter.Handle) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		params := httprouter.ParamsFromContext(r.Context())
		h(w, r, params)
	}
}
File: ./internal/cmd/auth.go
package main

import (
	"context"
	"net/http"
	"strings"
	"time"

	"github.com/dgrijalva/jwt-go"
	"github.com/julienschmidt/httprouter"
	_ "github.com/lib/pq"
)

type Claims struct {
	Userid int64
	jwt.StandardClaims
}

type AuthRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type AuthResponse struct {
	Token string `json:"token"`
}

func (app *application) jwtMiddleware(next httprouter.Handle) http.HandlerFunc {
	return wrapHandle(func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			http.Error(w, "Authorization header missing", http.StatusUnauthorized)
			return
		}

		tokenString := strings.TrimPrefix(authHeader, "Bearer ")
		if tokenString == "" {
			http.Error(w, "Invalid token format", http.StatusUnauthorized)
			return
		}

		claims := &Claims{}
		token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
			return app.jwtkey, nil
		})

		if err != nil || !token.Valid {
			http.Error(w, "Invalid token", http.StatusUnauthorized)
			return
		}

		// Add the username to the request context
		ctx := context.WithValue(r.Context(), "id", claims.Userid)
		r = r.WithContext(ctx)

		// Call the next handler
		next(w, r, ps)
	})
}

func (app *application) authHandler(w http.ResponseWriter, r *http.Request) { // Modified to enqueue
	app.queue <- struct{}{}
	defer func() {
		<-app.queue
	}()
	app.authWorker(w, r, httprouter.Params{})

}

func (app *application) authWorker(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	var req AuthRequest
	if err := app.readJSON(w, r, &req); err != nil {
		app.logger.Printf("Error reading JSON: %v", err)
		app.badRequestResponse(w, r)
		return
	}
	// Validate user credentials (e.g., check against database)
	// For simplicity, we'll assume the credentials are valid
	user, err := app.models.Shop.GetUserByUsername(req.Username)
	if user == nil {
		if err != nil {
			app.serverErrorResponse(w, r, err)
			return
		}
		user, err = app.models.Shop.InsertUser(req.Username, req.Password)
		if err != nil {
			app.serverErrorResponse(w, r, err)
			return
		}
		user.Password = req.Password
	}
	if user.Password != req.Password {
		app.authorizationErrorResponse(w, r)
		return
	}

	// Create JWT token
	expirationTime := time.Now().Add(time.Hour)
	claims := &Claims{
		Userid: user.ID,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(app.jwtkey)
	if err != nil {
		app.serverErrorResponse(w, r, err)
		return
	}

	// Return the token
	response := AuthResponse{Token: tokenString}
	app.writeJSON(w, http.StatusOK, response, nil)
}
File: ./internal/cmd/healthcheck.go
package main

import (
	"net/http"
)

func (app *application) healthcheckHandler(w http.ResponseWriter, r *http.Request) {
	env := envelope{
		"status": "available",
		"system_info": map[string]string{
			"environment": app.config.env,
			"version":     version,
		},
	}
	err := app.writeJSON(w, http.StatusOK, env, nil)
	if err != nil {
		app.serverErrorResponse(w, r, err)
	}
}
File: ./internal/cmd/main.go
package main

import (
	"context"
	"database/sql"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
	"github.com/wisp167/Shop/internal/data"
)

const version = "1.0.0"

type config struct {
	port       int
	env        string
	numWorkers int
	db         struct {
		dsn          string
		host         string
		name         string
		user         string
		password     string
		maxOpenConns int
		maxIdleConns int
		maxIdleTime  string
	}
}

type application struct {
	config config
	logger *log.Logger
	models data.Models
	queue  chan struct{}
	jwtkey []byte
}

func main() {
	var cfg config
	var jwtkey string

	godotenv.Load(".env")

	logger := log.New(os.Stdout, "", log.Ldate|log.Ltime|log.Lshortfile)

	EnvPort, err := strconv.Atoi(os.Getenv("PORT"))
	if err != nil {
		logger.Fatal(err)
	}

	DbMaxOpenCons, err := strconv.Atoi(os.Getenv("DATABASE_MAX_OPEN_CONNS"))
	if err != nil {
		logger.Fatal(err)
	}
	DbMaxIdleCons, err := strconv.Atoi(os.Getenv("DATABASE_MAX_IDLE_CONNS"))
	if err != nil {
		logger.Fatal(err)
	}

	flag.StringVar(&jwtkey, "jwt-key", os.Getenv("JWT_KEY"), "jwt key")
	flag.IntVar(&cfg.port, "port", EnvPort, "API server port")
	flag.StringVar(&cfg.env, "env", os.Getenv("ENV"), "Enviroment (development|staging|production)")

	flag.StringVar(&cfg.db.host, "db-host", os.Getenv("DATABASE_HOST"), "PostgreSQL host")                 // Default to localhost for Docker Compose
	flag.StringVar(&cfg.db.name, "db-name", os.Getenv("DATABASE_NAME"), "PostgreSQL database name")        // Default to greenlight
	flag.StringVar(&cfg.db.user, "db-user", os.Getenv("DATABASE_USER"), "PostgreSQL user")                 // Default to user
	flag.StringVar(&cfg.db.password, "db-password", os.Getenv("DATABASE_PASSWORD"), "PostgreSQL password") // Default to password

	flag.IntVar(&cfg.db.maxOpenConns, "db-max-open-conns", DbMaxOpenCons, "PostgreSQL max open connections")
	flag.IntVar(&cfg.db.maxIdleConns, "db-max-idle-conns", DbMaxIdleCons, "PostgreSQL max idle connections")
	flag.StringVar(&cfg.db.maxIdleTime, "db-max-idle-time", os.Getenv("DATABASE_MAX_IDLE_TIME"), "PostgreSQL max connection idle time")

	cfg.numWorkers = 50

	flag.Parse()

	logger.Printf("Config: %v", cfg)

	logger.Printf("DSN String: %s", cfg.db.dsn)

	db, err := openDB(cfg)
	if err != nil {
		logger.Fatal(err)
	}

	defer db.Close()

	logger.Printf("database connection established")

	app := &application{
		config: cfg,
		logger: logger,
		models: data.NewModels(db),
		jwtkey: []byte(jwtkey),
		queue:  make(chan struct{}, cfg.numWorkers),
	}

	srv := &http.Server{
		Addr:         fmt.Sprintf(":%d", cfg.port),
		Handler:      app.routes(),
		IdleTimeout:  time.Minute,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 30 * time.Second,
	}

	logger.Printf("starting %s server on %s", cfg.env, srv.Addr)

	go func() {
		// service connections
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("listen: %s\\n", err)
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server with
	// a timeout of 5 seconds.
	quit := make(chan os.Signal, 1)
	// kill (no param) default send syscall.SIGTERM
	// kill -2 is syscall.SIGINT
	// kill -9 is syscall. SIGKILL but can"t be catch, so don't need add it
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Println("Shutdown Server ...")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err = srv.Shutdown(ctx); err != nil {
		log.Fatal("Server Shutdown:", err)
	}
	// catching ctx.Done(). timeout of 5 seconds.
	select {
	case <-ctx.Done():
		log.Println("timeout of 5 seconds.")
	}
	log.Println("Server exiting")

	err = srv.ListenAndServe()
	logger.Fatal(err)

}

func openDB(cfg config) (*sql.DB, error) {
	cfg.db.dsn = fmt.Sprintf("postgres://%s:%s@%s:5432/%s?sslmode=disable",
		cfg.db.user,
		cfg.db.password,
		cfg.db.host,
		cfg.db.name,
	)
	db, err := sql.Open("postgres", cfg.db.dsn)
	if err != nil {
		return nil, err
	}

	db.SetMaxOpenConns(cfg.db.maxOpenConns)
	db.SetMaxIdleConns(cfg.db.maxIdleConns)

	duration, err := time.ParseDuration(cfg.db.maxIdleTime)
	if err != nil {
		return nil, err
	}
	db.SetConnMaxIdleTime(duration)

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)

	defer cancel()

	err = db.PingContext(ctx)
	if err != nil {
		return nil, err
	}
	return db, nil
}
File: ./internal/cmd/routes.go
package main

import (
	"net/http"

	"github.com/julienschmidt/httprouter"
)

func (app *application) routes() *httprouter.Router {
	router := httprouter.New()
	router.NotFound = http.HandlerFunc(app.notFoundResponse)

	router.MethodNotAllowed = http.HandlerFunc(app.methodNotAllowedResponse)

	router.HandlerFunc(http.MethodGet, "/v1/healthz", app.healthcheckHandler) //health
	router.HandlerFunc(http.MethodPost, "/api/auth", app.authHandler)
	router.HandlerFunc(http.MethodGet, "/api/buy/:item", app.jwtMiddleware(app.buyItemHandler))
	router.HandlerFunc(http.MethodPost, "/api/sendCoin", app.jwtMiddleware(app.sendCoinHandler))
	router.HandlerFunc(http.MethodGet, "/api/info", app.jwtMiddleware(app.getInfoHandler))
	return router
}
